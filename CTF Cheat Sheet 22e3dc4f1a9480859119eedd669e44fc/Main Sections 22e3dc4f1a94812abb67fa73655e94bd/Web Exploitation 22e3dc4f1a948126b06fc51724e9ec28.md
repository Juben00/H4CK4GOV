# Web Exploitation

# General Overview

---

## **SQL Injection**

SQL Injection is a vulnerability where an application takes input from a user and doesn't vaildate that the user's input doesn't contain additional SQL.

`<?php
    $username = $_GET['username']; // kchung
    $result = mysql_query("SELECT * FROM users WHERE username='$username'");
?>`

If we look at the $username variable, under normal operation we might expect the username parameter to be a real username (e.g. kchung).

But a malicious user might submit different kind of data. For example, consider if the input wasÂ `'`?

The application would crash because the resulting SQL query is incorrect.

`SELECT * FROM users WHERE username='''`

**Note**

Notice the extra single quote at the end.

With the knowledge that a single quote will cause an error in the application we can expand a little more on SQL Injection.

What if our input wasÂ `' OR 1=1`?

`SELECT * FROM users WHERE username='' OR 1=1`

1 is indeed equal to 1. This equates to true in SQL. If we reinterpret this the SQL statement is really saying

`SELECT * FROM users WHERE username='' OR true`

This will return every row in the table because each row that exists must be true.

We can also inject comments and termination characters likeÂ `--`Â orÂ `/*`Â orÂ `;`. This allows you to terminate SQL queries after your injected statements. For exampleÂ `'--`Â is a common SQL injection payload.

`SELECT * FROM users WHERE username=''-- '`

This payload sets the username parameter to an empty string to break out of the query and then adds a comment (`--`) that effectively hides the second single quote.

Using this technique of adding SQL statements to an existing query we can force databases to return data that it was not meant to return.

---

### **Preventing SQL Injection**

The best way to prevent SQL Injection is to use prepared statements. Prepared statements are a way to execute SQL queries that separates the query logic from the data being passed into the query.

`<?php
    $stmt = $pdo->prepare('SELECT * FROM users WHERE username = :username');
    $stmt->execute(['username' => $username]);
?>`

In this example, theÂ `:username`Â is a placeholder that is replaced with the value of theÂ `$username`Â variable. The database driver will automatically escape the value ofÂ `$username`Â to prevent SQL Injection.

Another way to prevent SQL Injection is to use an ORM (Object Relational Mapping) library. ORM libraries abstract the database layer and allow you to interact with the database using objects instead of raw SQL queries.

`<?php
    $user = User::where('username', $username)->first();
?>`

ORM libraries automatically escape user input to prevent SQL Injection.

---

## **Command Injection**

Command Injection is a vulnerability that allows an attacker to submit system commands to a computer running a website. This happens when the application fails to encode user input that goes into a system shell. It is very common to see this vulnerability when a developer uses theÂ `system()`Â command or its equivalent in the programming language of the application.

`import os

domain = user_input() # ctf101.org

os.system('ping ' + domain)`

The above code when used normally will ping theÂ `ctf101.org`Â domain.

But consider what would happen if theÂ `user_input()`Â function returned different data?

`import os

domain = user_input() # ; ls

os.system('ping ' + domain)`

Because of the additional semicolon, theÂ `os.system()`Â function is instructed to run two commands.

It looks to the program as:

`ping ; ls`

**Note**

The semicolon terminates a command in bash and allows you to put another command after it.

Because theÂ `ping`Â command is being terminated and theÂ `ls`Â command is being added on, theÂ `ls`Â command will be run in addition to the empty ping command!

This is the core concept behind command injection. TheÂ `ls`Â command could of course be switched with another command (e.g. wget, curl, bash, etc.)

Command injection is a very common means of privelege escalation within web applications and applications that interface with system commands. Many kinds of home routers take user input and directly append it to a system command. For this reason, many of those home router models are vulnerable to command injection.

### Example Payloads

- `;ls`
- `$(ls)`
- ``ls``

---

## **Directory Traversal**

Directory Traversal is a vulnerability where an application takes in user input and uses it in a directory path.

Any kind of path controlled by user input that isn't properly sanitized or properly sandboxed could be vulnerable to directory traversal.

For example, consider an application that allows the user to choose what page to load from a GET parameter.

`<?php
    $page = $_GET['page']; // index.php
    include("/var/www/html/" . $page);
?>`

Under normal operation the page would beÂ `index.php`. But what if a malicious user gave in something different?

`<?php
    $page = $_GET['page']; // ../../../../../../../../etc/passwd
    include("/var/www/html/" . $page);
?>`

Here the user is submittingÂ `../../../../../../../../etc/passwd`.

This will result in the PHP interpreter leaving the directory that it is coded to look in ('/var/www/html') and instead be forced up to the root folder.

`include("/var/www/html/../../../../../../../../etc/passwd");`

Ultimately this will becomeÂ `/etc/passwd`Â because the computer will not go a directory above its top directory.

Thus the application will load theÂ `/etc/passwd`Â file and emit it to the user like so:

`root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false
systemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false
systemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false
systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false
_apt:x:104:65534::/nonexistent:/bin/false`

This same concept can be applied to applications where some input is taken from a user and then used to access a file or path or similar. This vulnerability very often can be used to leak sensitive data or extract application source code to find other vulnerabilities.

---

## **Cross Site Request Forgery (CSRF)**

A Cross Site Request Forgery or CSRF Attack, pronouncedÂ *see surf*, is an attack on an authenticated user which uses a state session in order to perform state changing attacks like a purchase, a transfer of funds, or a change of email address.

The entire premise of CSRF is based on session hijacking, usually by injecting malicious elements within a webpage through anÂ `<img>`Â tag or anÂ `<iframe>`Â where references to external resources are unverified.

### Using CSRF

`GET`Â requests are often used by websites to get user input. Say a user signs in to an banking site which assigns their browser a cookie which keeps them logged in. If they transfer some money, the URL that is sent to the server might have the pattern:

`http://securibank.com/transfer.do?acct=[RECEPIENT]&amount=[DOLLARS]`

Knowing this format, an attacker can send an email with a hyperlink to be clicked on or they can include an image tag of 0 by 0 pixels which will automatically be requested by the browser such as:

`<img src="http://securibank.com/transfer.do?acct=[RECEPIENT]&amount=[DOLLARS]" width="0" height="0" border="0">`

---

## **Cross Site Scripting (XSS)**

Cross Site Scripting or XSS is a vulnerability where on user of an application can send JavaScript that is executed by the browser of another user of the same application.

This is a vulnerability because JavaScript has a high degree of control over a user's web browser.

For example JavaScript has the ability to:

- Modify the page (called the DOM)
- Send more HTTP requests
- Access cookies

By combining all of these abilities, XSS can maliciously use JavaScript to extract user's cookies and send them to an attacker controlled server. XSS can also modify the DOM to phish users for their passwords. This only scratches the surface of what XSS can be used to do.

XSS is typically broken down into three categories:

- Reflected XSS
- Stored XSS
- DOM XSS

### Reflected XSS

Reflected XSS is when an XSS exploit is provided through a URL paramater.

For example:

`https://ctf101.org?data=<script>alert(1)</script>`

You can see the XSS exploit provided in theÂ `data`Â GET parameter. If the application is vulnerable to reflected XSS, the application will take this data parameter value and inject it into the DOM.

For example:

`<html>
    <body>
        <script>alert(1)</script>
    </body>
</html>`

Depending on where the exploit gets injected, it may need to be constructed differently.

Also, the exploit payload can change to fit whatever the attacker needs it to do. Whether that is to extract cookies and submit it to an external server, or to simply modify the page to deface it.

One of the deficiencies of reflected XSS however is that it requires the victim to access the vulnerable page from an attacker controlled resource. Notice that if the data parameter wasn't provided, the exploit wouldn't work.

In many situations, reflected XSS is detected by the browser because it is very simple for a browser to detect malicous XSS payloads in URLs.

### Stored XSS

Stored XSS is different from reflected XSS in one key way. In reflected XSS, the exploit is provided through a GET parameter. But in stored XSS, the exploit is provided from the website itself.

Imagine a website that allows users to post comments. If a user can submit an XSS payload as a comment, and then have others view that malicious comment, it would be an example of stored XSS.

The reason being that the web site itself is serving up the XSS payload to other users. This makes it very difficult to detect from the browser's perspective and no browser is capable of generically preventing stored XSS from exploiting a user.

### DOM XSS

DOM XSS is XSS that is due to the browser itself injecting an XSS payload into the DOM. While the server itself may properly prevent XSS, it's possible that the client side scripts may accidentally take a payload and insert it into the DOM and cause the payload to trigger.

The server itself is not to blame, but the client side JavaScript files are causing the issue.

---

## **Server Side Request Forgery (SSRF)**

Server Side Request Forgery or SSRF is where an attacker is able to cause a web application to send a request that the attacker defines.

For example, say there is a website that lets you take a screenshot of any site on the internet.

Under normal usage a user might ask it to take a screenshot of a page like Google, or The New York Times. But what if a user does something more nefarious? What if they asked the site to take a picture of http://localhost ? Or perhaps tries to access something more useful like http://localhost/server-status ?

**Note**

127.0.0.1 (also known as localhost or loopback) represents the computer itself. Accessing localhost means you are accessing the computer's own internal network. Developers often use localhost as a way to access the services they have running on their own computers.

Depending on what the response from the site is the attacker may be able to gain additional information about what's running on the computer itself.

In addition, the requests originating from the server would come from the server's IP not the attackers IP. Because of that, it is possible that the attacker might be able to access internal resources that he wouldn't normally be able to access.

Another usage for SSRF is to create a simple port scanner to scan the internal network looking

---

## **PHP**

PHP is one of the most used languages for back-end web development and therefore it has become a target by hackers. PHP is a language which makes it painful to be secure for most instances, making it every hacker's dream target.

### Overview

PHP is a C-like language which uses tags enclosed byÂ `<?php ... ?>`Â (sometimes justÂ `<? ... ?>`). It is inlined into HTML. A word of advice is to keep the php docs open because function names are strange due to the fact that the length of function name is used to be the key in PHP's internal dictionary, so function names were shortened/lengthened to make the lookup faster. Other things include:

- Variables start with $:Â `$name`
- Variable variables:Â `$$name`
- Request-specific dictionaries:Â `$_GET, $_POST, $_SERVER`

### Example

`<?php
    if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['email']) && isset($_POST['password'])) {
        $db = new mysqli('127.0.0.1', 'cs3284', 'cs3284', 'logmein');
        $email = $_POST['email'];
        $password = sha1($_POST['password']);
        $res = $db->query("SELECT * FROM users WHERE email = '$email' AND password = '$password'");
        if ($row = $res->fetch_assoc()) {
            $_SESSION['id'] = $row['id'];
            header('Location: index.php');
            die();
        }
   }
?>
<html>...`

This example PHP simply checks the POST data for an email and password. If the password is equal to the hashed password in the database, the use is logged in and redirected to the index page.

The lineÂ `email = '$email'`Â uses automatic string interpolation in order to convert $email into a string to compare with the database.

### Type Juggling

PHP will do just about anything to match with a loose comparison (\=\=) which means things can be 'equal' (\=\=) orÂ *really*Â equal (\=\=\=). The implicit integer parsing to strings is the root cause of a lot of issues in PHP.

### Type Comparison Table

### **Comparisons of $x with PHP Functions**

| **Expression** | **gettype()** | **empty()** | **is_null()** | **isset()** | **boolean:Â `if($x)`** |
| --- | --- | --- | --- | --- | --- |
| $x = ""; | string | TRUE | FALSE | TRUE | FALSE |
| $x = null; | NULL | TRUE | TRUE | FALSE | FALSE |
| var $x; | NULL | TRUE | TRUE | FALSE | FALSE |
| $x is undefined | NULL | TRUE | TRUE | FALSE | FALSE |
| $x = array(); | array | TRUE | FALSE | TRUE | FALSE |
| $x = array('a', 'b'); | array | FALSE | FALSE | TRUE | TRUE |
| $x = false; | boolean | TRUE | FALSE | TRUE | FALSE |
| $x = true; | boolean | FALSE | FALSE | TRUE | TRUE |
| $x = 1; | integer | FALSE | FALSE | TRUE | TRUE |
| $x = 42; | integer | FALSE | FALSE | TRUE | TRUE |
| $x = 0; | integer | TRUE | FALSE | TRUE | FALSE |
| $x = -1; | integer | FALSE | FALSE | TRUE | TRUE |
| $x = "1"; | string | FALSE | FALSE | TRUE | TRUE |
| $x = "0"; | string | TRUE | FALSE | TRUE | FALSE |
| $x = "-1"; | string | FALSE | FALSE | TRUE | TRUE |
| $x = "php"; | string | FALSE | FALSE | TRUE | TRUE |
| $x = "true"; | string | FALSE | FALSE | TRUE | TRUE |
| $x = "false"; | string | FALSE | FALSE | TRUE | TRUE |

### **"==" Comparisons**

|  | **TRUE** | **FALSE** | **1** | **0** | **-1** | **"1"** | **"0"** | **"-1"** | **NULL** | **array()** | **"php"** | **""** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| TRUE | ==TRUE== | FALSE | ==TRUE== | FALSE | ==TRUE== | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE |
| FALSE | FALSE | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | ==TRUE== | ==TRUE== | FALSE | ==TRUE== |
| 1 | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| 0 | FALSE | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | ==TRUE== | FALSE | ==TRUE== | ==TRUE== |
| -1 | ==TRUE== | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE |
| "1" | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| "0" | FALSE | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE |
| "-1" | ==TRUE== | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE |
| NULL | FALSE | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | ==TRUE== | ==TRUE== | FALSE | ==TRUE== |
| array() | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | ==TRUE== | FALSE | FALSE |
| "php" | ==TRUE== | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE |
| "" | FALSE | ==TRUE== | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | ==TRUE== |

### **"===" Comparisons**

|  | **TRUE** | **FALSE** | **1** | **0** | **-1** | **"1"** | **"0"** | **"-1"** | **NULL** | **array()** | **"php"** | **""** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| TRUE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| 1 | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| 0 | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| -1 | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| "1" | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE |
| "0" | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE | FALSE |
| "-1" | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE | FALSE |
| NULL | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE | FALSE |
| array() | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE | FALSE |
| "php" | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== | FALSE |
| "" | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | ==TRUE== |

### File Inclusion

PHP has multiple ways to include other source files such as require, require_once and include. These can take a dynamic string such asÂ `require $_GET['page'] . ".php";`Â which is usually seen in templating.

### PHP Stream Filters

PHP has its own URL scheme:Â `php://...`Â and its main purpose is to filter output automatically. It can automatically remove certain HTML tags and can base64 encode as well.

### Example

`$fp = fopen('php://output', 'w');
stream_filter_append(
       $fp,
       'string.strip_tags',
       STREAM_FILTER_WRITE,
       array('b','i','u'));
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
/* <b>bolded text</b> enlarged to a level 1 heading */`

### Exploitation

These filters can also be used on input such as:

- `php://filter/convert.base64-encode/resource={file}`
- `include`,Â `file_get_contents()`, etc. support URLs including PHP stream filter URLs (`php://`)
- `include`Â normally evaluates any PHP code (in tags) it finds, but if itâ€™s base64 encoded it can be used to leak source

---

# In-Depth Breakdown

## **Enumeration**

Find all content and functionality on a website, to get an idea of the attack surface. Often through fuzzing

### **Find Content**

For a quick recursive map of a website the `feroxbuster` tool has great defaults. While it uses a medium-sized wordlist to test for non-404-like responses, it also parses links and directory listings in responses to discover even more content. While it does not have much customization for a scan, it's great for a first scan if you need something quick:
`$ feroxbuster -u http://example.com`

https://github.com/epi052/feroxbuster

For **more control** over your scan, `ffuf` is a great choice. It allows you to easily create your own rules for exactly how the website should be fuzzed, like *where* inputs are placed, *what* is put there, and *how* a good response is defined.
https://github.com/ffuf/ffuf - Highly customizable web fuzzer that is fast and simple to use

Check out [FFUF.me](http://ffuf.me/) for a **great tutorial** on how to use various options in the tool.

Examples

```
# # Simplest example, using a wordlist at the start of a path and auto-calibrating
$ ffuf -u http://example.com/FUZZ -w common.txt -ac
# # Probe for unknown virtual hosts on a domain by changing the Host header
$ ffuf -u http://example.com/ -H 'Host: FUZZ.example.com' -w subdomains.txt
# # Find parameters that alter the response
$ ffuf -u http://example.com/?FUZZ=1 -w parameters.txt
# # Use payload fuzzing to do less guesswork, for example Path Traversal
$ ffuf -u http://example.com/?page=FUZZ -w path-traversal.txt

# # POST with JSON data and fuzz value, filtered on 'error' RegEx
$ ffuf -X POST -u http://example.com/ -H 'Content-Type: application/json' -d '{"name": "FUZZ", "anotherkey": "anothervalue"}' -fr 'error' -w values.txt
# # Fuzz multiple parameter and values at the same time, matching reflected values
$ ffuf -u http://example.com/?PARAM=VAL -w params.txt:PARAM -w values.txt:VAL -mr "VAL"
# # POST form data using command substitution for a 1-100 sequence of IDs
$ ffuf -X POST -u http://example.com/ -H 'Content-Type: application/x-www-form-urlencoded' -d 'id=FUZZ&action=view' -fs 1341 -w <(seq 1 100)
```

There is also a `ffuf` module in my [default](https://github.com/JorianWoltjer/default) tool!

```
$ default ffuf content http://example.com/
$ default ffuf param http://example.com/page
$ default ffuf vhost example.com

$ default ffuf auto example.com  # An attempt at combining content and vhost
```

### **Wordlists**

Good results come from good wordlists. You also don't want to wait weeks for a scan to complete, so a short but packed wordlist is often the best choice, while this depends on your test. The SecLists repository is a collection of many such wordlists for all kinds of purposes, including [discovering web content](https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content):
https://github.com/danielmiessler/SecLists

Collection of different types of wordlists from usernames and passwords to web content and payloads

- [`common.txt`](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/common.txt):
4715 common web **paths** (small), **alphabetically** ordered
- [`raft-large-files.txt`](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/raft-large-files.txt) & [`raft-large-directories.txt`](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/raft-large-directories.txt):
~100.000 total **files** and **directories** (large), ordered by **count**
- [`subdomains-5000.txt`](https://github.com/danielmiessler/SecLists/blob/master/Discovery/DNS/subdomains-top1million-5000.txt):
top 5000 **subdomains** (small), ordered by **count**

Another more recent resource is the *autogenerated* wordlists from Assetnote:

[https://wordlists.assetnote.io/](https://wordlists.assetnote.io/)

### Find Technologies

[Find out what websites are built with - Wappalyzer](https://www.wappalyzer.com/)

Browser Extension to detect the front- and backend technologies used by a website

## **Passively Find Content**

As opposed to the brute-force methods shown above, most public websites get indexed many times by search engines and other services. We can use these to find content that was indexed, but not easily findable in the results by creating complex queries.

### **Googling**

Google search indexes lots of web pages and makes them easily searchable. This is nice for us web testers because we can ask it for pages from a certain site, and gives us lots of results. We can also ask for more specific and obscure results.

One simple way to ensure we only get pages on the target domain is to use the `site:` keyword. Simply put your domain in there to only find results on that host.

> site:gitbook.com
> 

Then we can add things like `ext:` to specify the **file extension** of the webpage.

> site:gitbook.com ext:pdf
> 

Another useful trick is the `-` sign. Use this with any keyword to **exclude** any results that match that word.

> site:gitbook.com ext:pdf -files.gitbook.com
> 

### **Viewing Cache**

When looking at a result from your query, you might find a page that has some interesting content in the description but appears offline when you click the link. Google has a previous (cached) version of the site with the content, but right now you can only see a preview.

To view it, you can click the

[](https://book.jorianwoltjer.com/~gitbook/image?url=https%3A%2F%2F3698848315-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F677wrA8ZfiPs1U4l5uR6%252Fuploads%252FABPGmF31hFKsBBMKHh8x%252Fimage.png%3Falt%3Dmedia%26token%3Dade0dae5-41aa-44e9-8e39-14573e5bb47b&width=300&dpr=4&quality=100&sign=f7987a66&sv=2)

three dots after the result, press the

[](https://book.jorianwoltjer.com/~gitbook/image?url=https%3A%2F%2F3698848315-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F677wrA8ZfiPs1U4l5uR6%252Fuploads%252FZ2MGDugqU4C2gmu5JJNY%252Fimage.png%3Falt%3Dmedia%26token%3D25bf0f89-9a48-4716-9a70-d986b7944497&width=300&dpr=4&quality=100&sign=82dd90d&sv=2)

arrow down, and view

**Cached**

. Another way to manually do this for

*any URL*

is by prefixing it with

```
cache:
```

, for example:

> cache:https://gitbook.com/about
> 

### **Internet Archive: [Wayback Machine](http://web.archive.org/)**

A more powerful version of a search engine cache is the Wayback Machine, which archives snapshots of websites at specific times. If a website was changed, or some information was removed, it can often still be found using this tool. Simply search for a URL and you'll find a calendar full of snapshots to choose from.

There may be a lot of snapshots and different pages. To analyze the results there are a few options like **Changes** which track changes in the HTML code delivered to the browser, show you at what points the biggest changes happened, and use the `@` icons to compare them. This way you won't have to search endlessly to find *that one* snapshot where the page changed.

[](https://book.jorianwoltjer.com/~gitbook/image?url=https%3A%2F%2F3698848315-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F677wrA8ZfiPs1U4l5uR6%252Fuploads%252Fr0D0SsS9XZjdYHKh1I8G%252Fimage.png%3Falt%3Dmedia%26token%3D6bfbe855-a935-4ed5-8ed4-7d53ad9e8b33&width=300&dpr=4&quality=100&sign=b1f8c62e&sv=2)

Another useful option is **URLs** which lists all known URLs in a table where you can search. The [`waybackurls`](https://github.com/tomnomnom/waybackurls) tool can also extract all these URLs for you to analyze locally with more tools and can be a very effective way of finding many pages with parameters too.

Copy

```
cat domains.txt | waybackurls | tee wayback-urls.txt
```

---

## **Fuzzing Inputs / Polyglots**

Here is a polyglot payload I made of a few different **injection** attacks with various pieces of syntax. If any part of this payload is **removed, transformed or causes errors** on the target, you might have injected something and it is worth reverse engineering what part of the payload caused it to see if it is exploitable ([url-encoded](https://gchq.github.io/CyberChef/#recipe=URL_Encode(true)&input=fDo8dT48Pz0tLT4iXCIxJ1wnYWBcYC8uLi9dJHt7PCVbJScifX0lcykmZ3Q7JTBkJTBhJUMwJThhJTNDxLzwn5Go4oCN8J%2BSu0ENCiUwMFw&ieol=CRLF), [JSON](https://gchq.github.io/CyberChef/#recipe=Escape_string('Special%20chars','Double',true,false,false)&input=fDo8dT48Pz0tLT4iXCIxJ1wnYWBcYC8uLi9dJHt7PCVbJScifX0lcykmZ3Q7JTBkJTBhJUMwJThhJTNDxLzwn5Go4oCN8J%2BSu0ENCiUwMFw&ieol=CRLF)):

Generic Payload

Copy

```
|:<u><?=-->"\"1'\'a`\`/../]${{<%[%'"}}%s)&gt;%0d%0a%C0%8a%3CÄ¼ðŸ‘¨â€ðŸ’»A
%00\
```

Here is another specifically for **blind command injection** that tries to work in as many different contexts as possible with filter bypasses. If the application waits for any multiple of 5 seconds, it has likely worked and you can try more targetted payloads ([url-encoded](https://gchq.github.io/CyberChef/#recipe=URL_Encode(true)&input=LyokKHNsZWVwIDUpYHNsZWVwIDVgYCovLXNsZWVwKDUpLScvKiQoc2xlZXAgNSlgc2xlZXAgNWAgIyovLXNsZWVwKDUpfHwnInx8c2xlZXAoNSl8fCIvKmAqLwpzbGVlcCA1), [JSON](https://gchq.github.io/CyberChef/#recipe=Escape_string('Special%20chars','Double',true,false,false)&input=LyokKHNsZWVwIDUpYHNsZWVwIDVgYCovLXNsZWVwKDUpLScvKiQoc2xlZXAgNSlgc2xlZXAgNWAgIyovLXNsZWVwKDUpfHwnInx8c2xlZXAoNSl8fCIvKmAqLwpzbGVlcCA1)):

Blind Command Injection

Copy

```
/*$(sleep 5)`sleep 5``*/-sleep(5)-'/*$(sleep 5)`sleep 5` #*/-sleep(5)||'"||sleep(5)||"/*`*/
sleep 5
```

For less attack-focussed fuzzing it is sometimes useful to find **what characters are allowed** to give you ideas on possible bypasses. Python's `string.printable` variable contains all printable ASCII characters. You can input this string and see if anything is blocked. If you only get a simple "error" message, you can use binary search to remove half of the payload and see what character causes the error (keep in mind that there may be multiple) ([url-encoded](https://gchq.github.io/CyberChef/#recipe=Unescape_string()URL_Encode(true)&input=MDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVohIiMkJSZcJygpKissLS4vOjs8PT4/QFtcXF1eX2B7fH1%2BIFx0XG5cclx4MGJceDBj), [JSON](https://gchq.github.io/CyberChef/#recipe=Unescape_string()Escape_string('Special%20chars','Double',true,false,false)&input=MDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVohIiMkJSZcJygpKissLS4vOjs8PT4/QFtcXF1eX2B7fH1%2BIFx0XG5cclx4MGJceDBj)):

Copy

```
>>> import string
>>> string.printable
'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
```

---

## **Client-Side**

Attacks on the browser, often involving the victim landing on an attacker's site

[Cross-Site Scripting (XSS)](https://book.jorianwoltjer.com/web/client-side/cross-site-scripting-xss)

[CSS Injection](https://book.jorianwoltjer.com/web/client-side/css-injection)

[Cross-Site Request Forgery (CSRF)](https://book.jorianwoltjer.com/web/client-side/cross-site-request-forgery-csrf)

[XS-Leaks](https://xsleaks.dev/)

[Client-Side Path Traversal (CSPT)](https://book.jorianwoltjer.com/web/client-side/client-side-path-traversal-cspt)

[CRLF / Header Injection](https://book.jorianwoltjer.com/web/client-side/crlf-header-injection)

[Window Popup Tricks](https://book.jorianwoltjer.com/web/client-side/window-popup-tricks)

[WebSockets](https://book.jorianwoltjer.com/web/client-side/websockets)

[Caching](https://book.jorianwoltjer.com/web/client-side/caching)

[Headless Browsers](https://book.jorianwoltjer.com/web/client-side/headless-browsers)

https://book.jorianwoltjer.com/web/client-side

---

## **Server-Side**

Attacks that have impact on the server, often by abusing dangerous functionality

[SQL Injection](https://book.jorianwoltjer.com/web/server-side/sql-injection)

[NoSQL Injection](https://book.jorianwoltjer.com/web/server-side/nosql-injection)

[GraphQL](https://book.jorianwoltjer.com/web/server-side/graphql)

[XML External Entities (XXE)](https://book.jorianwoltjer.com/web/server-side/xml-external-entities-xxe)

[HTTP Request Smuggling](https://book.jorianwoltjer.com/web/server-side/http-request-smuggling)

[Local File Disclosure](https://book.jorianwoltjer.com/web/server-side/local-file-disclosure)

[Arbitrary File Write](https://book.jorianwoltjer.com/web/server-side/arbitrary-file-write)

[Reverse Proxies](https://book.jorianwoltjer.com/web/server-side/reverse-proxies)

[ImageMagick](https://book.jorianwoltjer.com/web/server-side/imagemagick)

https://book.jorianwoltjer.com/web/server-side

---

## **Frameworks**

Libraries for specific programming languages that make development easier, with their own quirks

[Flask](https://book.jorianwoltjer.com/web/frameworks/flask)

[Ruby on Rails](https://book.jorianwoltjer.com/web/frameworks/ruby-on-rails)

[NodeJS](https://book.jorianwoltjer.com/web/frameworks/nodejs)

[Bun](https://book.jorianwoltjer.com/web/frameworks/bun)

[WordPress](https://book.jorianwoltjer.com/web/frameworks/wordpress)

[Angular](https://book.jorianwoltjer.com/web/frameworks/angular)

https://book.jorianwoltjer.com/web/frameworks